## 导航流程

用户发出 URL 请求到页面开始解析的这个过程，就叫做<b>导航</b>。

这也就是解释了为什么为什么叫做导航流程，可以理解为导航流程就是一个主流程。

![image](http://note.youdao.com/yws/res/3978/FC344F6BB8544940BEB3D1A8BD23CC3C)



我们不一定要把整个流程细节全部理清楚，但是基本要知道：
1. 网络进程：该进程负责所有网络资源的请求。
2. 渲染进程：该进程负责资源的加载与渲染，一般一个tab对应一个渲染进程，但是如果多个tab是属于同一站点，或者根域名是一致的，那么他们会公用一个渲染进程。
3. 浏览器进程：它是一个主进程，负责进程之前的调配与浏览器状态的总控制。

## 渲染流程

我们平时常说的html/css/javascript等代码的渲染都是由<b>渲染进程</b>来完成。

接下来，我们重点看一下，渲染进程具体是如何工作的？


#### 一. 构建dom树

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

如何访问dom树呢？通过document对象访问，例如：

我们在Elements标签中访问html数据结构如下：
![image](http://note.youdao.com/yws/res/4003/AD4DC4CBBA734181BA39E88F69E3D8C6)

然后我们通过输出document输出dom树结构如下：

![image](http://note.youdao.com/yws/res/4007/51CBB173D88F47358F2219BB2C5D64BD)

我们可以感受到，其实dom和html的结构几乎是一样的，但是和html不同的是，<b>dom是存在于内存中的树结构，我们可以通过javascript来查询dom树中的节点，或者修改dom树。</b>
```
document.getElementsByTagName("p")[0].innerText = "black"
```

所以构建dom树的过程就是：通过html解析器将html转换成dom树的过程。
![image](http://note.youdao.com/yws/res/4053/04EB04BF481641599B9F5621912F7ACD)

> 拓展：html解析内部是如何构建dom树的。

#### 二. 样式计算，输出带样式的dom树

1. 把css转换成计算机能够理解的机构styleSheets

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

我们可以通过document.styleSheets访问：
![image](http://note.youdao.com/yws/res/4022/769923B129DF442BA23CBDEE34828BAA)

和dom类似，我们可以通过document.styleSheets去访问一些样式属性，或者修改修饰属性.

2. 转换样式表中的属性值，使其标准化

主要是css中有很多属性，例如2rem，blue,bold等属性值不容易被渲染引擎所理解，所以同一转换成容易理解的，标准的值

![image](http://note.youdao.com/yws/res/4045/2A18AD36AF804C27BB95E90F87D5ACD5)
从图中可以看到，2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……

3. 计算dom树节点的样式

这一步主要是计算dom树中每个节点的样式，最后输出的是一个带样式的dom树,并且这些样式被保存在ComputedStyle的结构里：
![image](http://note.youdao.com/yws/res/4030/CF4A3E52180A4F11B0A425211165AB31)

当然，我们也可以通过window.getComputedStyle获取指定标签的计算样式。
```
let ele = document.getElementsByTagName('body')[0];
window.getComputedStyle(ele, null)
```
返回值其实就是一个对象，里面记录了该标签的css属性以及值。
![image](http://note.youdao.com/yws/res/4037/644D6B0D89494A0888E62885DC334729)


这一步的最终输出结果：一颗带样式的dom树

![image](http://note.youdao.com/yws/res/4051/99E343BC24DF40448AD1BE11EF3D516D)


#### 三. 布局阶段

至此，我们已经生成了一颗带样式的dom，但是这还不足以显示到页面中，因为我们还不知道每个节点具体的位置几何信息，那么接下来要做的就是计算各个节点的位置，我们把这个阶段叫做<b>布局</b>

布局阶段主要做了两个事情：创建布局树和布局计算

1. 创建布局树

你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。

2. 布局计算

创建了布局树之后，就是进一步计算布局树中每个节点的位置啦。


#### 四：分层

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

> 熟悉ps的话，知道层的概念，我们的页面也一样，用户看到的页面其实是很多个图层叠加之后产生的效果。

我们可以打开 开发者工具 的layer标签，查看分层效果

![image](http://note.youdao.com/yws/res/4077/20E270535CAC4DDC99335EA09D581B58)

接下来我们看看满足哪些条件时，就会为节点创建一个单独的层？

1. 第一：拥有层叠上下文属性的元素会被提为单独的一层

![image](http://note.youdao.com/yws/res/4084/F0E93191BBFE47E699A355F21E277FCD)

从上面，我们也看到啦，定位元素，使用css滤镜的元素，定义透明度的元素，都会被单独提为一层。


2. 第二：需要裁剪的地方也会被创建新的图层

![image](http://note.youdao.com/yws/res/4089/3FB56B621642422B89CEE6B1C93BE041)

如图所示，如果文字超出了div的范围，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

#### 五. 图层绘制

图层的绘制其实就是会把一个图层的绘制拆分成很多的小的绘制指令，然后将这些指令按照顺序组成一个待绘制列表。

#### 六. 栅格化操作

图层绘制阶段，只是生成了一个待绘制的指令列表，真正的绘制是由合成线程来操作的。

首先来看一下，主线程和合成线程的关系：
![image](http://note.youdao.com/yws/res/4104/1DC0CFB324C94EA7A69291A55551B58F)

合成线程会将图层分割成一个个的图块，然后合成线程会根据视口附近的图块来优先生成位图（所谓栅格化其实就是将图块转成位图的过程）

栅格化的过程中通常会使用GPU来加速生成位图，这个过程也叫快速栅格化，生成的位图存储在GPU内存中。而GPU操作是有一个单独的GPU进程的，也就是说 快速栅格化的过程：其实就是渲染进程将生成图块的指令交给了GPU进程，然后在GPU进程中，生成位图，并且存储在GPU的内存中。

![image](http://note.youdao.com/yws/res/4118/6430F5B3F49F42C680D0F38E2114F8F3)

#### 七. 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

#### 总结

1. 构建DOM树：渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 构建带样式的DOM树：渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 布局排版：创建布局树，并计算元素的布局信息。
4. 分层：对布局树进行分层，并生成分层树。
5. 绘制图层：为每个图层生成绘制列表，并将其提交到合成线程。
6. 栅格化操作：合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成：合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 显示：浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 重排与重绘

#### 重排

重排：即重新排版或者重新布局。

如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

#### 重绘

重绘：即重新绘制

如果通过 JavaScript 修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。<b>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</b>

#### 合成

如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成

例如：我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。

> 拓展：<a href="https://www.cnblogs.com/chris-oil/p/10800961.html">你真的了解回流和重绘吗</a>

